<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://d3js.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src https://fonts.gstatic.com; img-src 'self' data:; object-src 'none'; base-uri 'none';">
    <title>Forcepoint Mind Map Canvas</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --fp-green: #00af9a; --fp-dark-green: #007565; --fp-navy: #1d252c;
            --fp-gray: #636569; --fp-light: #f5f6f6;
            --bg-color: var(--fp-light); --header-bg: var(--fp-navy);
            --card-bg: #ffffff; --text-primary: var(--fp-navy);
            --text-secondary: var(--fp-gray); --border-color: #e2e8f0;
            --node-bg: #ffffff; --edge-color: #cbd5e0;
            --grid-color: #d1d1d1; --sidebar-width: 320px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode {
            --bg-color: #0f172a; --header-bg: #020617;
            --card-bg: #1e293b; --text-primary: #f1f5f9;
            --text-secondary: #94a3b8; --border-color: #334155;
            --node-bg: #1e293b; --edge-color: #475569;
            --grid-color: #334155;
        }

        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: var(--bg-color); color: var(--text-primary); display: flex; height: 100vh; }

        header { position: absolute; top: 0; left: 0; right: 0; height: 64px; background-color: var(--header-bg); color: white; display: flex; align-items: center; justify-content: space-between; padding: 0 24px; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        header h1 { margin: 0; font-size: 1.25rem; font-weight: 600; }

        #global-finder { width: var(--sidebar-width); background: var(--card-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; z-index: 950; transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); margin-top: 64px; height: calc(100vh - 64px); }
        #global-finder.collapsed { transform: translateX(-100%); position: absolute; }

        .finder-header { padding: 16px; background: var(--fp-green); color: white; font-weight: 800; font-size: 11px; letter-spacing: 1px; text-transform: uppercase; }
        .finder-scroll { flex: 1; overflow-y: auto; padding: 8px 0; }

        .finder-node { display: flex; flex-direction: column; }
        .finder-row { display: flex; align-items: center; padding: 8px 16px; cursor: pointer; font-size: 13px; transition: background 0.2s; border-radius: 4px; margin: 0 8px; color: var(--text-primary); }
        .finder-row:hover { background: var(--fp-light); }
        .dark-mode .finder-row:hover { background: rgba(255,255,255,0.05); }
        .finder-row--active { background: rgba(0, 175, 154, 0.1) !important; color: var(--fp-green) !important; font-weight: 600; }
        
        .finder-children { display: none; padding-left: 12px; border-left: 1px solid var(--border-color); margin-left: 22px; }
        .finder-node.expanded > .finder-children { display: block; }
        
        .toggle-icon { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; transition: transform 0.2s; opacity: 0.5; margin-right: 4px; }
        .finder-node.expanded > .finder-row .toggle-icon { transform: rotate(90deg); }
        .leaf-dot { width: 6px; height: 6px; background: var(--fp-green); border-radius: 50%; margin-right: 14px; margin-left: 5px; opacity: 0.4; }

        .sidebar-toggle { position: absolute; top: 80px; left: var(--sidebar-width); background: var(--fp-green); color: white; border: none; width: 24px; height: 48px; border-radius: 0 8px 8px 0; cursor: pointer; z-index: 960; display: flex; align-items: center; justify-content: center; transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        #global-finder.collapsed + .sidebar-toggle { left: 0; }

        #main-content { flex: 1; position: relative; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; cursor: grab; background-image: radial-gradient(circle, var(--grid-color) 1.5px, transparent 1.5px); background-size: 48px 48px; }

        .node rect { fill: var(--node-bg); stroke: var(--border-color); stroke-width: 1.5px; rx: 12; ry: 12; transition: all 0.3s ease; }
        .node--selected rect { stroke: var(--fp-green) !important; stroke-width: 3px !important; }
        .node text { font-size: 13px; font-weight: 600; pointer-events: none; fill: var(--text-primary); transition: fill 0.3s ease; }
        .link { fill: none; stroke: var(--edge-color); stroke-width: 2.5px; transition: all 0.3s ease; }
        .node--compressed { opacity: 0.4; }
        .node--eol rect { fill: #f1f5f9; stroke: #cbd5e0; opacity: 0.6; }
        .node--eol text { fill: #94a3b8; }
        .dark-mode .node--eol rect { fill: #1e293b; stroke: #334155; }

        /* LOD Styles */
        .zoom-far .node-label, .zoom-far .details-container { display: none !important; }
        .zoom-far .node rect { stroke-width: 4px; rx: 20; ry: 20; }
        .zoom-mid .details-container { display: none !important; }

        /* Search Heatmap Styles */
        .node--match rect { stroke: #ffeb3b !important; stroke-width: 4px !important; filter: drop-shadow(0 0 8px rgba(255, 235, 59, 0.6)); }
        .node--match-ancestor rect { stroke: rgba(255, 235, 59, 0.4) !important; stroke-width: 2px !important; }
        .link--match { stroke: #ffeb3b !important; stroke-opacity: 1 !important; stroke-width: 4px !important; }

        /* Minimap Styles */
        #minimap-container { position: absolute; bottom: 32px; right: 32px; width: 200px; height: 150px; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; box-shadow: var(--shadow-lg); overflow: hidden; z-index: 100; pointer-events: none; }
        #minimap-svg { width: 100%; height: 100%; }
        #minimap-viewport { fill: rgba(0, 175, 154, 0.1); stroke: var(--fp-green); stroke-width: 1px; }

        #breadcrumb-navigator { position: absolute; top: 80px; left: 40px; z-index: 900; background: var(--card-bg); padding: 8px 16px; border-radius: 8px; box-shadow: var(--shadow); border: 1px solid var(--border-color); display: flex; align-items: center; gap: 8px; font-size: 12px; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        #breadcrumb-navigator.visible { opacity: 1; pointer-events: auto; }
        .breadcrumb-item { cursor: pointer; color: var(--text-primary); }
        .breadcrumb-item:hover { color: var(--fp-green); text-decoration: underline; }

        /* Rich Knowledge Card Styling */
        .node-details { padding: 20px; display: flex; flex-direction: column; gap: 12px; color: var(--text-primary); width: 100%; height: 100%; overflow: hidden; background: transparent; }
        .detail-title { font-weight: 700; font-size: 15px; line-height: 1.2; color: var(--text-primary); margin-bottom: 2px; }
        .node-summary { font-size: 12px; line-height: 1.5; color: var(--text-secondary); flex: 1; overflow-y: auto; scrollbar-width: thin; padding-right: 4px; margin-bottom: 8px; }
        .node-summary::-webkit-scrollbar { width: 3px; }
        .node-summary::-webkit-scrollbar-thumb { background: var(--fp-green); }

        .related-links-container { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); }
        .related-links-title { font-size: 10px; font-weight: 800; color: var(--fp-green); text-transform: uppercase; margin-bottom: 6px; }
        .related-link-item { display: block; font-size: 11px; color: var(--text-primary); text-decoration: none; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .related-link-item:hover { color: var(--fp-green); text-decoration: underline; }

        .type-tag { display: inline-block; padding: 4px 10px; border-radius: 6px; font-size: 10px; text-transform: uppercase; font-weight: 800; letter-spacing: 1px; width: fit-content; }
        .tag-document { background: #f0fff4; color: #2f855a; }
        .tag-platform { background: var(--fp-navy); color: white; }
        .tag-status-current { background: #e6fffa; color: #008673; border: 1px solid #b2f5ea; }
        .tag-status-eol { background: #fff5f5; color: #c53030; border: 1px solid #feb2b2; }
        .dark-mode .tag-document { background: #22543d; color: #c6f6d5; }
        .dark-mode .tag-status-eol { background: #742a2a; color: #fed7d7; }

        .external-link-btn { display: flex; align-items: center; justify-content: center; gap: 8px; background-color: var(--fp-green); color: white; padding: 10px 20px; border-radius: 10px; text-decoration: none; font-weight: 700; font-size: 13px; transition: all 0.2s; width: 100%; box-shadow: 0 4px 10px rgba(0, 175, 154, 0.2); margin-top: auto; }
        .external-link-btn:hover { background-color: var(--fp-dark-green); transform: translateY(-2px); }

        .controls { position: absolute; bottom: 32px; left: 32px; display: flex; gap: 12px; z-index: 100; }
        .btn { background: var(--card-bg); border: 1px solid var(--border-color); width: 44px; height: 44px; border-radius: 12px; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: var(--shadow); font-size: 20px; color: var(--text-primary); transition: all 0.2s; }

        #loading-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: var(--bg-color); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; transition: opacity 0.5s ease-out; }
        .spinner { width: 40px; height: 40px; border: 4px solid var(--border-color); border-top: 4px solid var(--fp-green); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 16px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loading-overlay"><div class="spinner"></div><div style="font-weight: 500;">Building Knowledge Base...</div></div>
    <header><h1>Forcepoint Documentation</h1><div class="header-actions"><input type="text" id="search-input" placeholder="Search..."><button class="theme-toggle" id="theme-toggle">ðŸŒ“</button></div></header>
    <aside id="global-finder"><div class="finder-header">Documentation Explorer</div><div class="finder-scroll" id="finder-list"></div></aside>
    <button class="sidebar-toggle" id="finder-toggle" onclick="toggleSidebar()">â€¹</button>
    <main id="main-content">
        <div id="breadcrumb-navigator"></div>
        <div id="canvas-container">
            <div id="minimap-container"><svg id="minimap-svg"><g id="minimap-content"></g><rect id="minimap-viewport"></rect></svg></div>
            <div class="controls"><button class="btn" onclick="zoomIn()">+</button><button class="btn" onclick="zoomOut()">-</button><button class="btn" onclick="resetZoom()">âŸ²</button></div>
        </div>
    </main>

    <script>
        const config = { nodeWidth: 320, nodeHeight: 52, expandedHeight: 280, directoryHeight: 360, levelWidth: 450, directoryThreshold: 12 };
        let root, svg, g, linkGroup, nodeGroup, zoom, i = 0, selectedNode = null;
        let minimapSvg, minimapG, minimapViewport, minimapScale;
        let summariesLookup = null;
        const duration = 600;

        function toggleSidebar() {
            const isCollapsed = document.getElementById('global-finder').classList.toggle('collapsed');
            document.getElementById('finder-toggle').innerText = isCollapsed ? 'â€º' : 'â€¹';
            setTimeout(() => {
                const w = document.getElementById('canvas-container').clientWidth;
                const h = document.getElementById('canvas-container').clientHeight;
                svg.attr("width", w).attr("height", h);
                checkVisibility();
            }, 300);
        }

        async function init() {
            let data;
            try { 
                // Load structure first
                data = await d3.json('d3-data.json?v=' + new Date().getTime()); 
                // Lazy load summaries in background
                d3.json('summaries.json').then(res => {
                    summariesLookup = res;
                    if (selectedNode) update(selectedNode); // Refresh if something is already selected
                });
            } catch (error) { return; }
            
            const container = d3.select("#canvas-container");
            svg = container.append("svg").attr("width", "100%").attr("height", "100%").style("overflow", "visible");
            g = svg.append("g"); linkGroup = g.append("g").attr("class", "links"); nodeGroup = g.append("g").attr("class", "nodes");
            
            // Minimap Init
            minimapSvg = d3.select("#minimap-svg");
            minimapG = d3.select("#minimap-content");
            minimapViewport = d3.select("#minimap-viewport");

            zoom = d3.zoom().scaleExtent([0.02, 3]).on("zoom", (event) => {
                g.attr("transform", event.transform);
                
                // 1. Semantic Zooming (LOD)
                const scale = event.transform.k;
                g.classed("zoom-far", scale < 0.15);
                g.classed("zoom-mid", scale >= 0.15 && scale < 0.5);
                g.classed("zoom-close", scale >= 0.5);

                // 2. Viewport Culling
                checkVisibility();

                // 3. Minimap Sync
                updateMinimapViewport(event.transform);
            });
            svg.call(zoom);

            root = d3.hierarchy(data, d => d.children);
            root.sort((a, b) => {
                if (a.data.name === 'ONE') return -1;
                if (b.data.name === 'ONE') return 1;
                return a.data.name.localeCompare(b.data.name);
            });

            root.eachAfter(d => {
                d.id = ++i;
                d.value = d.children ? d.children.reduce((sum, c) => sum + c.value, 0) : 1;
                if (d.children && d.children.length > config.directoryThreshold) d.data.isDirectory = true;
            });

            renderFinderRecursive(root, document.getElementById('finder-list'));

            if (root.children) root.children.forEach(d => { if (d.children) d.children.forEach(collapse); });
            update(root); resetZoom();
            document.getElementById('loading-overlay').style.opacity = '0';
            setTimeout(() => document.getElementById('loading-overlay').remove(), 500);

            d3.select("#search-input").on("input", function() {
                const term = this.value.toLowerCase();
                
                // Heatmap logic
                root.descendants().forEach(d => {
                    d.data.isMatch = term && d.data.name.toLowerCase().includes(term);
                    d.data.hasMatchChild = false;
                });

                if (term) {
                    root.descendants().filter(d => d.data.isMatch).forEach(d => {
                        d.ancestors().forEach(a => a.data.hasMatchChild = true);
                    });
                    
                    const firstMatch = root.descendants().find(d => d.data.isMatch);
                    if (firstMatch) window.focusNodeById(firstMatch.id);
                }
                update(root);
            });
        }

        function checkVisibility() {
            const transform = d3.zoomTransform(svg.node());
            const width = document.getElementById('canvas-container').clientWidth;
            const height = document.getElementById('canvas-container').clientHeight;
            
            nodeGroup.selectAll("g.node").each(function(d) {
                const x = d.y * transform.k + transform.x;
                const y = d.x * transform.k + transform.y;
                const isVisible = x > -config.nodeWidth * transform.k && x < width + config.nodeWidth * transform.k &&
                                  y > -config.expandedHeight * transform.k && y < height + config.expandedHeight * transform.k;
                d3.select(this).style("display", isVisible ? null : "none");
            });
        }

        function updateMinimapNodes() {
            if (!root) return;
            const nodes = root.descendants();
            const miniNodes = minimapG.selectAll("rect").data(nodes, d => d.id);
            
            miniNodes.enter().append("rect")
                .attr("width", config.nodeWidth).attr("height", config.nodeHeight)
                .attr("rx", 4).attr("ry", 4)
                .merge(miniNodes)
                .attr("x", d => d.y).attr("y", d => d.x - config.nodeHeight/2)
                .attr("fill", d => d.data.isMatch ? "#ffeb3b" : (d.data.type === 'platform' ? 'var(--fp-navy)' : 'var(--fp-green)'))
                .attr("opacity", d => d.data.isMatch || d.data.hasMatchChild ? 1 : 0.4);
            
            miniNodes.exit().remove();
        }

        function updateMinimapViewport(transform) {
            const width = document.getElementById('canvas-container').clientWidth;
            const height = document.getElementById('canvas-container').clientHeight;
            const mw = 200, mh = 150;
            
            const treeW = (treeBounds.maxX - treeBounds.minX) + config.nodeWidth;
            const treeH = (treeBounds.maxY - treeBounds.minY) + config.nodeHeight;
            
            minimapScale = Math.min(mw / treeW, mh / treeH) * 0.9;
            const offsetX = (mw - treeW * minimapScale) / 2 - treeBounds.minX * minimapScale;
            const offsetY = (mh - treeH * minimapScale) / 2 - treeBounds.minY * minimapScale;
            
            minimapG.attr("transform", `translate(${offsetX}, ${offsetY}) scale(${minimapScale})`);
            
            // Sync Viewport Rect
            const vx = (-transform.x / transform.k) * minimapScale + offsetX;
            const vy = (-transform.y / transform.k) * minimapScale + offsetY;
            const vw = (width / transform.k) * minimapScale;
            const vh = (height / transform.k) * minimapScale;
            
            minimapViewport.attr("x", vx).attr("y", vy).attr("width", vw).attr("height", vh);
        }

        function renderFinderRecursive(d, container) {
            if (d.depth === 0) { d.children.forEach(c => renderFinderRecursive(c, container)); return; }
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'finder-node'; nodeDiv.dataset.id = d.id;
            const row = document.createElement('div'); row.className = 'finder-row';
            const hasChildren = d.children || d._children;
            if (hasChildren) {
                row.innerHTML = `<span class="toggle-icon">â–¶</span> ðŸ“ ${d.data.name}`;
                row.onclick = (e) => { e.stopPropagation(); nodeDiv.classList.toggle('expanded'); window.focusNodeById(d.id); };
            } else {
                row.innerHTML = `<span class="leaf-dot"></span> ðŸ“„ ${d.data.name}`;
                row.onclick = (e) => { e.stopPropagation(); window.focusNodeById(d.id); };
            }
            nodeDiv.appendChild(row);
            if (hasChildren) {
                const childContainer = document.createElement('div'); childContainer.className = 'finder-children';
                (d.children || d._children).forEach(c => renderFinderRecursive(c, childContainer));
                nodeDiv.appendChild(childContainer);
            }
            container.appendChild(nodeDiv);
        }

        function collapse(d) { if (d.children) { d._children = d.children; d._children.forEach(collapse); d.children = null; } }

        window.focusNodeById = (id) => {
            const target = root.descendants().find(d => String(d.id) === String(id));
            if (!target) return;

            // Accordion Logic: Resolve the expansion path and collapse others
            const ancestors = target.ancestors();
            for (let i = ancestors.length - 1; i >= 0; i--) {
                const nodeOnPath = ancestors[i];
                const parent = ancestors[i+1] || root;
                
                if (parent.children) {
                    parent.children.forEach(sibling => {
                        if (sibling !== nodeOnPath) collapse(sibling);
                    });
                }

                if (nodeOnPath._children) {
                    nodeOnPath.children = nodeOnPath._children;
                    nodeOnPath._children = null;
                }
                
                const sidebarNode = document.querySelector(`.finder-node[data-id="${nodeOnPath.id}"]`);
                if (sidebarNode) sidebarNode.classList.add('expanded');
            }

            selectNode(target);
            update(target);
            
            document.querySelectorAll('.finder-row').forEach(el => el.classList.remove('finder-row--active'));
            const activeRow = document.querySelector(`.finder-node[data-id="${id}"] > .finder-row`);
            if (activeRow) {
                activeRow.classList.add('finder-row--active');
                activeRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            const w = document.getElementById('canvas-container').clientWidth;
            const h = document.getElementById('canvas-container').clientHeight;
            let scale = target.data.type === 'document' ? 1.2 : 0.8;
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(w/3, h/2).scale(scale).translate(-target.y, -target.x));
        };

        function calculateDynamicTree() {
            const layout = d3.tree().nodeSize([160, config.levelWidth]);
            const treeData = layout(root); const nodes = treeData.descendants();
            if (selectedNode) {
                const activePath = new Set(selectedNode.ancestors());
                nodes.sort((a,b) => a.x - b.x);
                nodes.forEach((d, index) => {
                    const isFocus = activePath.has(d) || (selectedNode.parent && activePath.has(d.parent));
                    d.x = index > 0 ? nodes[index-1].x + (isFocus ? 160 : 45) : 0;
                });
            }
            return treeData;
        }

        let treeBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };

        function update(source) {
            const treeData = calculateDynamicTree();
            const nodes = treeData.descendants();
            nodes.forEach(d => { d.y = d.depth * config.levelWidth; });
            
            // Pre-calculate bounds for minimap
            treeBounds.minX = d3.min(nodes, d => d.y) || 0;
            treeBounds.maxX = d3.max(nodes, d => d.y) || 0;
            treeBounds.minY = d3.min(nodes, d => d.x) || 0;
            treeBounds.maxY = d3.max(nodes, d => d.x) || 0;
            
            const node = nodeGroup.selectAll("g.node").data(nodes, d => d.id);
            const nodeEnter = node.enter().append("g")
                .attr("class", d => "node node--" + (d.data.type || 'category') + (d.data.status === 'eol' ? ' node--eol' : ''))
                .attr("transform", d => "translate(" + (source.y0 ?? source.y ?? 0) + "," + (source.x0 ?? source.x ?? 0) + ")")
                .on("click", (event, d) => window.focusNodeById(d.id));

            nodeEnter.append("rect").attr("width", config.nodeWidth).attr("height", config.nodeHeight).attr("y", -config.nodeHeight/2);
            nodeEnter.append("text").attr("class", "node-label").attr("dy", ".35em").attr("x", 16).text(d => d.data.name.length > 35 ? d.data.name.substring(0, 32) + "..." : d.data.name);
            nodeEnter.append("foreignObject").attr("class", "details-container").attr("width", config.nodeWidth).attr("y", -config.expandedHeight/2).style("opacity", 0).style("pointer-events", "none");

            const nodeUpdate = nodeEnter.merge(node);
            const activePath = selectedNode ? new Set(selectedNode.ancestors()) : new Set();
            nodeUpdate.classed("node--selected", d => d === selectedNode)
                      .classed("node--compressed", d => selectedNode && !activePath.has(d) && !(d.parent && activePath.has(d.parent)))
                      .classed("node--match", d => d.data.isMatch)
                      .classed("node--match-ancestor", d => d.data.hasMatchChild);

            nodeUpdate.transition().duration(duration).attr("transform", d => "translate(" + d.y + "," + d.x + ")");
            nodeUpdate.select("rect").transition().duration(duration).attr("height", d => d === selectedNode ? (d.data.isDirectory ? config.directoryHeight : config.expandedHeight) : config.nodeHeight)
                .attr("y", d => { const h = d === selectedNode ? (d.data.isDirectory ? config.directoryHeight : config.expandedHeight) : config.nodeHeight; return -h/2; });

            nodeUpdate.select(".node-label").transition().duration(duration).style("opacity", d => d === selectedNode ? 0 : 1);

            nodeUpdate.each(function(d) {
                const fo = d3.select(this).select(".details-container");
                if (d === selectedNode) {
                    fo.style("pointer-events", "auto").transition().duration(duration).style("opacity", 1);
                    const safeName = d.data.name.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#039;"}[m]));
                    const safeUrl = (d.data.url && /^https?:\/\//i.test(d.data.url)) ? d.data.url.replace(/"/g, "&quot;") : '';
                    
                    if (d.data.isDirectory) {
                        const items = (d.children || d._children || []).map(c => `<li class="directory-item" onclick="event.stopPropagation(); window.focusNodeById('${c.id}')">${c.data.name}</li>`).join("");
                        fo.html(`<div class="node-details directory-container" xmlns="http://www.w3.org/1999/xhtml"><div class="directory-header"><span>DIRECTORY</span><span>${(d.children||d._children).length} items</span></div><div class="detail-title">${safeName}</div><ul class="directory-list">${items}</ul></div>`);
                    } else {
                        const info = summariesLookup ? summariesLookup[d.data.url] : null;
                        const summaryText = info ? (info.summary || "No summary found.") : "Fetching intelligence...";
                        const safeSummary = summaryText.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#039;"}[m]));
                        
                        const statusBadge = d.data.status ? `<div class="type-tag tag-status-${d.data.status}">${d.data.status}</div>` : '';
                        const related = (info && info.relatedLinks || []).slice(0, 3).map(l => `<a href="${l.url}" class="related-link-item" target="_blank">ðŸ”— ${l.title}</a>`).join('');
                        const relatedHtml = related ? `<div class="related-links-container"><div class="related-links-title">Related Documentation</div>${related}</div>` : '';
                        
                        fo.html(`<div class="node-details" xmlns="http://www.w3.org/1999/xhtml"><div style="display:flex; gap:8px;">${statusBadge}<div class="type-tag tag-${d.data.type}">${d.data.type}</div></div><div class="detail-title">${safeName}</div><div class="node-summary">${safeSummary}</div>${relatedHtml}${safeUrl ? `<a href="${safeUrl}" target="_blank" class="external-link-btn" onclick="event.stopPropagation()">View Official Documentation â†—</a>` : ''}</div>`);
                    }
                } else {
                    fo.style("pointer-events", "none").transition().duration(duration).style("opacity", 0);
                }
            });

            node.exit().transition().duration(duration).attr("transform", d => "translate(" + source.y + "," + source.x + ")").remove();
            const link = linkGroup.selectAll("path.link").data(links, d => d.target.id);
            link.enter().insert("path", "g").attr("class", "link").attr("d", d => { const o = { x: source.x0 ?? source.x ?? 0, y: (source.y0 ?? source.y ?? 0) + config.nodeWidth }; return diagonal(o, o); })
                .merge(link).transition().duration(duration).attr("d", d => diagonal({ x: d.source.x, y: d.source.y + config.nodeWidth }, { x: d.target.x, y: d.target.y }))
                .attr("stroke-width", d => Math.max(2, Math.log(d.target.value || 1) * 1.5) + "px")
                .style("opacity", d => (activePath.has(d.target) || activePath.has(d.source)) ? 1 : (d.target.data.hasMatchChild || d.target.data.isMatch ? 0.8 : 0.15))
                .classed("link--match", d => d.target.data.isMatch || d.target.data.hasMatchChild);

            link.exit().remove();
            nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
            updateMinimapNodes();
            setTimeout(checkVisibility, duration + 50);
        }

        function diagonal(s, d) { return "M" + s.y + "," + s.x + "C" + (s.y + d.y) / 2 + "," + s.x + " " + (s.y + d.y) / 2 + "," + d.x + " " + d.y + "," + d.x; }

        function selectNode(d) {
            selectedNode = d; const nav = d3.select("#breadcrumb-navigator");
            if (!d) return nav.classed("visible", false);
            nav.classed("visible", true).html("");
            d.ancestors().reverse().forEach((a, i) => {
                if (i > 0) nav.append("span").text("â€º").style("opacity", 0.5).style("margin", "0 4px");
                nav.append("span").attr("class", "breadcrumb-item").text(a.data.name).on("click", (e) => { e.stopPropagation(); window.focusNodeById(a.id); });
            });
        }

        function zoomIn() { svg.transition().call(zoom.scaleBy, 1.4); }
        function zoomOut() { svg.transition().call(zoom.scaleBy, 0.7); }
        function resetZoom() { 
            const h = document.getElementById('canvas-container').clientHeight;
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(60, h/2).scale(0.7)); 
        }

        document.getElementById('theme-toggle').addEventListener('click', () => {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        });

        init();
    </script>
</body>
</html>